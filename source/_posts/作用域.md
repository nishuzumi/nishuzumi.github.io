---
title: 小记作用域
date: 2020-11-21 11:11:55
tags:
catagories:
- [JS]
- [前端]
- [All In Code]
---

## 前言 🎤
深入研究一下JS的作用域。
<!--more-->

## 作用域
当前作用域分为几大类
- 全局作用域
- 局部作用域
    - 函数作用域
    - 块作用域

总结来说就是三种：全局，函数，块。为了方便理解，**你可以认为全局作用域为一种特殊的函数作用域**。

## var let const

### var
`var`是早期js遗留下来的邪恶😈产物，`var`的作用范围在*全局作用域*和*函数作用域*之中，并不会被*块作用域*约束。  
顺带要说明的是，在非严格模式下，函数声明也不受到直接创建的块作用域影响。
```js
{
    let one = 1;
    function test(){
        alert(1)
    }
}
test() 
alert(one) //ReferenceError: one is not defined
```

因此，`var`的特性有
- 在一个作用域内可以重复定义，值由代码执行程度决定
- 会被提升，可以在*函数或者全局作用域*声明之前访问到，内容为undefined
- 不受*块作用域*影响
### let
`let`是ES6新出的声明方式，通过`let`声明的内容将会受到*块作用域*的约束。
```js
+function test(){
    let one = 1;
    if(true){
        let one = 2;
        console.log(2)
    }
    console.log(1)

    {
        console.log(out)

        let out = 3;
    }
}()

/*
2
1
Uncaught ReferenceError: Cannot access 'out' before initialization
    at test (repl:10:21)
*/
```

上面的代码说明了`let`几个特点
- 在一个作用域内不可以重复定义
- 不会被提升（其实某种意义上来说是被提升了，但是没有初始化）
- 受到*所有的作用域*约束

### const
`const`也是ES6新出的声明方式，和`let`极为相似，唯一不同的是，你无法对其指向进行修改。
```js
const x = 1;
x = 2 // ❌

const x = {
    inner:1
}

x.inner = 2 // ✅
```

## 调用栈
>调用栈是解释器（比如浏览器中的 JavaScript 解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。

当执行任何一个函数，引擎都会往调用栈中押入一个新的函数，并且执行，如果继续调用其他函数，则会反复这个过程。知道执行完成后，就会进行出栈操作。当然，栈东西太多，就会溢出。  

这里说明调用栈的目的，其实是为了清清楚楚的和作用域分割开来，**作用域不是调用栈，而且和调用栈也没有太大的关系**

## 作用域链
传统情况下的作用域链就是`Scopes`，但是在ES6中，推荐了一种新的描述规范，名为`词法环境`。浏览器和Nodejs中，能看到的内容为`[[Scopes]]`，但是他们但原理其实是一摸一样的。为了方便理解，这里就使用`词法环境进行理解`。  
值得注意的是，`词法环境`只是个概念，你是无法直接观测`词法环境`的内容。但是你可以使用它来更好的理解*作用域链*。  

词法环境一般包含这些内容：
- 外层环境的引用
- 词法环境内容

外层环境引用是表示用于查找的上层环境指向，而词法环境内容是表示当前词法环境中各种变量，函数声明等内容。  

你可以想像成，每一个作用域，都有一个连接外层作用域的变量，而作用域链就是这么来的。当你在一个内部作用域尝试调用非当前作用域的变量时，就会逐层的往外层作用域进行查找。但是有一点，作用域链不会保存所有的作用域，只会保存有着联系的作用域。当你创建一个闭包的时候，就会和外部的一个作用域产生联系。

{% img /images/作用域-2020-11-21-18-01-01.png %}  
这张图很好的阐述了词法环境的概念。

## 作用域链增强
当遇到`wtih`或者`try/catch的catch`时，会在作用域前端临时增加一个作用域。用于存储临时作用域，比如`catch`中会临时存储抛出的`error`对象。

## 尾调用优化
要触发尾调用优化首先要满足几个条件。
- 严格模式下运行
- 返回的部分是执行尾调用函数
- 函数返回时不需要进行额外处理
- 调用的函数不能是闭包

```js
function fib(n,cur,next){
    'use strict'
    if(n < 1) return cur
    return fib( n - 1,next,next + cur)
}

console.log(fib(45,0,1))
```